// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$GroupFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() notFound,
    required TResult Function() groupAlreadyExists,
    required TResult Function() unableToUpdate,
    required TResult Function() unableToDelete,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? notFound,
    TResult? Function()? groupAlreadyExists,
    TResult? Function()? unableToUpdate,
    TResult? Function()? unableToDelete,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? notFound,
    TResult Function()? groupAlreadyExists,
    TResult Function()? unableToUpdate,
    TResult Function()? unableToDelete,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GroupUnexpected value) unexpected,
    required TResult Function(_GroupNotFound value) notFound,
    required TResult Function(_GroupAlreadyExists value) groupAlreadyExists,
    required TResult Function(_GroupUnableToUpdate value) unableToUpdate,
    required TResult Function(_GroupUnableToDelete value) unableToDelete,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GroupUnexpected value)? unexpected,
    TResult? Function(_GroupNotFound value)? notFound,
    TResult? Function(_GroupAlreadyExists value)? groupAlreadyExists,
    TResult? Function(_GroupUnableToUpdate value)? unableToUpdate,
    TResult? Function(_GroupUnableToDelete value)? unableToDelete,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GroupUnexpected value)? unexpected,
    TResult Function(_GroupNotFound value)? notFound,
    TResult Function(_GroupAlreadyExists value)? groupAlreadyExists,
    TResult Function(_GroupUnableToUpdate value)? unableToUpdate,
    TResult Function(_GroupUnableToDelete value)? unableToDelete,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GroupFailureCopyWith<$Res> {
  factory $GroupFailureCopyWith(
          GroupFailure value, $Res Function(GroupFailure) then) =
      _$GroupFailureCopyWithImpl<$Res, GroupFailure>;
}

/// @nodoc
class _$GroupFailureCopyWithImpl<$Res, $Val extends GroupFailure>
    implements $GroupFailureCopyWith<$Res> {
  _$GroupFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$GroupUnexpectedImplCopyWith<$Res> {
  factory _$$GroupUnexpectedImplCopyWith(_$GroupUnexpectedImpl value,
          $Res Function(_$GroupUnexpectedImpl) then) =
      __$$GroupUnexpectedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GroupUnexpectedImplCopyWithImpl<$Res>
    extends _$GroupFailureCopyWithImpl<$Res, _$GroupUnexpectedImpl>
    implements _$$GroupUnexpectedImplCopyWith<$Res> {
  __$$GroupUnexpectedImplCopyWithImpl(
      _$GroupUnexpectedImpl _value, $Res Function(_$GroupUnexpectedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$GroupUnexpectedImpl implements _GroupUnexpected {
  const _$GroupUnexpectedImpl();

  @override
  String toString() {
    return 'GroupFailure.unexpected()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$GroupUnexpectedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() notFound,
    required TResult Function() groupAlreadyExists,
    required TResult Function() unableToUpdate,
    required TResult Function() unableToDelete,
  }) {
    return unexpected();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? notFound,
    TResult? Function()? groupAlreadyExists,
    TResult? Function()? unableToUpdate,
    TResult? Function()? unableToDelete,
  }) {
    return unexpected?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? notFound,
    TResult Function()? groupAlreadyExists,
    TResult Function()? unableToUpdate,
    TResult Function()? unableToDelete,
    required TResult orElse(),
  }) {
    if (unexpected != null) {
      return unexpected();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GroupUnexpected value) unexpected,
    required TResult Function(_GroupNotFound value) notFound,
    required TResult Function(_GroupAlreadyExists value) groupAlreadyExists,
    required TResult Function(_GroupUnableToUpdate value) unableToUpdate,
    required TResult Function(_GroupUnableToDelete value) unableToDelete,
  }) {
    return unexpected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GroupUnexpected value)? unexpected,
    TResult? Function(_GroupNotFound value)? notFound,
    TResult? Function(_GroupAlreadyExists value)? groupAlreadyExists,
    TResult? Function(_GroupUnableToUpdate value)? unableToUpdate,
    TResult? Function(_GroupUnableToDelete value)? unableToDelete,
  }) {
    return unexpected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GroupUnexpected value)? unexpected,
    TResult Function(_GroupNotFound value)? notFound,
    TResult Function(_GroupAlreadyExists value)? groupAlreadyExists,
    TResult Function(_GroupUnableToUpdate value)? unableToUpdate,
    TResult Function(_GroupUnableToDelete value)? unableToDelete,
    required TResult orElse(),
  }) {
    if (unexpected != null) {
      return unexpected(this);
    }
    return orElse();
  }
}

abstract class _GroupUnexpected implements GroupFailure {
  const factory _GroupUnexpected() = _$GroupUnexpectedImpl;
}

/// @nodoc
abstract class _$$GroupNotFoundImplCopyWith<$Res> {
  factory _$$GroupNotFoundImplCopyWith(
          _$GroupNotFoundImpl value, $Res Function(_$GroupNotFoundImpl) then) =
      __$$GroupNotFoundImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GroupNotFoundImplCopyWithImpl<$Res>
    extends _$GroupFailureCopyWithImpl<$Res, _$GroupNotFoundImpl>
    implements _$$GroupNotFoundImplCopyWith<$Res> {
  __$$GroupNotFoundImplCopyWithImpl(
      _$GroupNotFoundImpl _value, $Res Function(_$GroupNotFoundImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$GroupNotFoundImpl implements _GroupNotFound {
  const _$GroupNotFoundImpl();

  @override
  String toString() {
    return 'GroupFailure.notFound()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$GroupNotFoundImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() notFound,
    required TResult Function() groupAlreadyExists,
    required TResult Function() unableToUpdate,
    required TResult Function() unableToDelete,
  }) {
    return notFound();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? notFound,
    TResult? Function()? groupAlreadyExists,
    TResult? Function()? unableToUpdate,
    TResult? Function()? unableToDelete,
  }) {
    return notFound?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? notFound,
    TResult Function()? groupAlreadyExists,
    TResult Function()? unableToUpdate,
    TResult Function()? unableToDelete,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GroupUnexpected value) unexpected,
    required TResult Function(_GroupNotFound value) notFound,
    required TResult Function(_GroupAlreadyExists value) groupAlreadyExists,
    required TResult Function(_GroupUnableToUpdate value) unableToUpdate,
    required TResult Function(_GroupUnableToDelete value) unableToDelete,
  }) {
    return notFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GroupUnexpected value)? unexpected,
    TResult? Function(_GroupNotFound value)? notFound,
    TResult? Function(_GroupAlreadyExists value)? groupAlreadyExists,
    TResult? Function(_GroupUnableToUpdate value)? unableToUpdate,
    TResult? Function(_GroupUnableToDelete value)? unableToDelete,
  }) {
    return notFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GroupUnexpected value)? unexpected,
    TResult Function(_GroupNotFound value)? notFound,
    TResult Function(_GroupAlreadyExists value)? groupAlreadyExists,
    TResult Function(_GroupUnableToUpdate value)? unableToUpdate,
    TResult Function(_GroupUnableToDelete value)? unableToDelete,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound(this);
    }
    return orElse();
  }
}

abstract class _GroupNotFound implements GroupFailure {
  const factory _GroupNotFound() = _$GroupNotFoundImpl;
}

/// @nodoc
abstract class _$$GroupAlreadyExistsImplCopyWith<$Res> {
  factory _$$GroupAlreadyExistsImplCopyWith(_$GroupAlreadyExistsImpl value,
          $Res Function(_$GroupAlreadyExistsImpl) then) =
      __$$GroupAlreadyExistsImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GroupAlreadyExistsImplCopyWithImpl<$Res>
    extends _$GroupFailureCopyWithImpl<$Res, _$GroupAlreadyExistsImpl>
    implements _$$GroupAlreadyExistsImplCopyWith<$Res> {
  __$$GroupAlreadyExistsImplCopyWithImpl(_$GroupAlreadyExistsImpl _value,
      $Res Function(_$GroupAlreadyExistsImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$GroupAlreadyExistsImpl implements _GroupAlreadyExists {
  const _$GroupAlreadyExistsImpl();

  @override
  String toString() {
    return 'GroupFailure.groupAlreadyExists()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$GroupAlreadyExistsImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() notFound,
    required TResult Function() groupAlreadyExists,
    required TResult Function() unableToUpdate,
    required TResult Function() unableToDelete,
  }) {
    return groupAlreadyExists();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? notFound,
    TResult? Function()? groupAlreadyExists,
    TResult? Function()? unableToUpdate,
    TResult? Function()? unableToDelete,
  }) {
    return groupAlreadyExists?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? notFound,
    TResult Function()? groupAlreadyExists,
    TResult Function()? unableToUpdate,
    TResult Function()? unableToDelete,
    required TResult orElse(),
  }) {
    if (groupAlreadyExists != null) {
      return groupAlreadyExists();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GroupUnexpected value) unexpected,
    required TResult Function(_GroupNotFound value) notFound,
    required TResult Function(_GroupAlreadyExists value) groupAlreadyExists,
    required TResult Function(_GroupUnableToUpdate value) unableToUpdate,
    required TResult Function(_GroupUnableToDelete value) unableToDelete,
  }) {
    return groupAlreadyExists(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GroupUnexpected value)? unexpected,
    TResult? Function(_GroupNotFound value)? notFound,
    TResult? Function(_GroupAlreadyExists value)? groupAlreadyExists,
    TResult? Function(_GroupUnableToUpdate value)? unableToUpdate,
    TResult? Function(_GroupUnableToDelete value)? unableToDelete,
  }) {
    return groupAlreadyExists?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GroupUnexpected value)? unexpected,
    TResult Function(_GroupNotFound value)? notFound,
    TResult Function(_GroupAlreadyExists value)? groupAlreadyExists,
    TResult Function(_GroupUnableToUpdate value)? unableToUpdate,
    TResult Function(_GroupUnableToDelete value)? unableToDelete,
    required TResult orElse(),
  }) {
    if (groupAlreadyExists != null) {
      return groupAlreadyExists(this);
    }
    return orElse();
  }
}

abstract class _GroupAlreadyExists implements GroupFailure {
  const factory _GroupAlreadyExists() = _$GroupAlreadyExistsImpl;
}

/// @nodoc
abstract class _$$GroupUnableToUpdateImplCopyWith<$Res> {
  factory _$$GroupUnableToUpdateImplCopyWith(_$GroupUnableToUpdateImpl value,
          $Res Function(_$GroupUnableToUpdateImpl) then) =
      __$$GroupUnableToUpdateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GroupUnableToUpdateImplCopyWithImpl<$Res>
    extends _$GroupFailureCopyWithImpl<$Res, _$GroupUnableToUpdateImpl>
    implements _$$GroupUnableToUpdateImplCopyWith<$Res> {
  __$$GroupUnableToUpdateImplCopyWithImpl(_$GroupUnableToUpdateImpl _value,
      $Res Function(_$GroupUnableToUpdateImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$GroupUnableToUpdateImpl implements _GroupUnableToUpdate {
  const _$GroupUnableToUpdateImpl();

  @override
  String toString() {
    return 'GroupFailure.unableToUpdate()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GroupUnableToUpdateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() notFound,
    required TResult Function() groupAlreadyExists,
    required TResult Function() unableToUpdate,
    required TResult Function() unableToDelete,
  }) {
    return unableToUpdate();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? notFound,
    TResult? Function()? groupAlreadyExists,
    TResult? Function()? unableToUpdate,
    TResult? Function()? unableToDelete,
  }) {
    return unableToUpdate?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? notFound,
    TResult Function()? groupAlreadyExists,
    TResult Function()? unableToUpdate,
    TResult Function()? unableToDelete,
    required TResult orElse(),
  }) {
    if (unableToUpdate != null) {
      return unableToUpdate();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GroupUnexpected value) unexpected,
    required TResult Function(_GroupNotFound value) notFound,
    required TResult Function(_GroupAlreadyExists value) groupAlreadyExists,
    required TResult Function(_GroupUnableToUpdate value) unableToUpdate,
    required TResult Function(_GroupUnableToDelete value) unableToDelete,
  }) {
    return unableToUpdate(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GroupUnexpected value)? unexpected,
    TResult? Function(_GroupNotFound value)? notFound,
    TResult? Function(_GroupAlreadyExists value)? groupAlreadyExists,
    TResult? Function(_GroupUnableToUpdate value)? unableToUpdate,
    TResult? Function(_GroupUnableToDelete value)? unableToDelete,
  }) {
    return unableToUpdate?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GroupUnexpected value)? unexpected,
    TResult Function(_GroupNotFound value)? notFound,
    TResult Function(_GroupAlreadyExists value)? groupAlreadyExists,
    TResult Function(_GroupUnableToUpdate value)? unableToUpdate,
    TResult Function(_GroupUnableToDelete value)? unableToDelete,
    required TResult orElse(),
  }) {
    if (unableToUpdate != null) {
      return unableToUpdate(this);
    }
    return orElse();
  }
}

abstract class _GroupUnableToUpdate implements GroupFailure {
  const factory _GroupUnableToUpdate() = _$GroupUnableToUpdateImpl;
}

/// @nodoc
abstract class _$$GroupUnableToDeleteImplCopyWith<$Res> {
  factory _$$GroupUnableToDeleteImplCopyWith(_$GroupUnableToDeleteImpl value,
          $Res Function(_$GroupUnableToDeleteImpl) then) =
      __$$GroupUnableToDeleteImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GroupUnableToDeleteImplCopyWithImpl<$Res>
    extends _$GroupFailureCopyWithImpl<$Res, _$GroupUnableToDeleteImpl>
    implements _$$GroupUnableToDeleteImplCopyWith<$Res> {
  __$$GroupUnableToDeleteImplCopyWithImpl(_$GroupUnableToDeleteImpl _value,
      $Res Function(_$GroupUnableToDeleteImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$GroupUnableToDeleteImpl implements _GroupUnableToDelete {
  const _$GroupUnableToDeleteImpl();

  @override
  String toString() {
    return 'GroupFailure.unableToDelete()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GroupUnableToDeleteImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() notFound,
    required TResult Function() groupAlreadyExists,
    required TResult Function() unableToUpdate,
    required TResult Function() unableToDelete,
  }) {
    return unableToDelete();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? notFound,
    TResult? Function()? groupAlreadyExists,
    TResult? Function()? unableToUpdate,
    TResult? Function()? unableToDelete,
  }) {
    return unableToDelete?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? notFound,
    TResult Function()? groupAlreadyExists,
    TResult Function()? unableToUpdate,
    TResult Function()? unableToDelete,
    required TResult orElse(),
  }) {
    if (unableToDelete != null) {
      return unableToDelete();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GroupUnexpected value) unexpected,
    required TResult Function(_GroupNotFound value) notFound,
    required TResult Function(_GroupAlreadyExists value) groupAlreadyExists,
    required TResult Function(_GroupUnableToUpdate value) unableToUpdate,
    required TResult Function(_GroupUnableToDelete value) unableToDelete,
  }) {
    return unableToDelete(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GroupUnexpected value)? unexpected,
    TResult? Function(_GroupNotFound value)? notFound,
    TResult? Function(_GroupAlreadyExists value)? groupAlreadyExists,
    TResult? Function(_GroupUnableToUpdate value)? unableToUpdate,
    TResult? Function(_GroupUnableToDelete value)? unableToDelete,
  }) {
    return unableToDelete?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GroupUnexpected value)? unexpected,
    TResult Function(_GroupNotFound value)? notFound,
    TResult Function(_GroupAlreadyExists value)? groupAlreadyExists,
    TResult Function(_GroupUnableToUpdate value)? unableToUpdate,
    TResult Function(_GroupUnableToDelete value)? unableToDelete,
    required TResult orElse(),
  }) {
    if (unableToDelete != null) {
      return unableToDelete(this);
    }
    return orElse();
  }
}

abstract class _GroupUnableToDelete implements GroupFailure {
  const factory _GroupUnableToDelete() = _$GroupUnableToDeleteImpl;
}

/// @nodoc
mixin _$MemberFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() notFound,
    required TResult Function() unableToUpdate,
    required TResult Function() unableToDelete,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? notFound,
    TResult? Function()? unableToUpdate,
    TResult? Function()? unableToDelete,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? notFound,
    TResult Function()? unableToUpdate,
    TResult Function()? unableToDelete,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MemberUnexpected value) unexpected,
    required TResult Function(_MemberNotFound value) notFound,
    required TResult Function(_MemberUnableToUpdate value) unableToUpdate,
    required TResult Function(_MemberUnableToDelete value) unableToDelete,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_MemberUnexpected value)? unexpected,
    TResult? Function(_MemberNotFound value)? notFound,
    TResult? Function(_MemberUnableToUpdate value)? unableToUpdate,
    TResult? Function(_MemberUnableToDelete value)? unableToDelete,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MemberUnexpected value)? unexpected,
    TResult Function(_MemberNotFound value)? notFound,
    TResult Function(_MemberUnableToUpdate value)? unableToUpdate,
    TResult Function(_MemberUnableToDelete value)? unableToDelete,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MemberFailureCopyWith<$Res> {
  factory $MemberFailureCopyWith(
          MemberFailure value, $Res Function(MemberFailure) then) =
      _$MemberFailureCopyWithImpl<$Res, MemberFailure>;
}

/// @nodoc
class _$MemberFailureCopyWithImpl<$Res, $Val extends MemberFailure>
    implements $MemberFailureCopyWith<$Res> {
  _$MemberFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$MemberUnexpectedImplCopyWith<$Res> {
  factory _$$MemberUnexpectedImplCopyWith(_$MemberUnexpectedImpl value,
          $Res Function(_$MemberUnexpectedImpl) then) =
      __$$MemberUnexpectedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MemberUnexpectedImplCopyWithImpl<$Res>
    extends _$MemberFailureCopyWithImpl<$Res, _$MemberUnexpectedImpl>
    implements _$$MemberUnexpectedImplCopyWith<$Res> {
  __$$MemberUnexpectedImplCopyWithImpl(_$MemberUnexpectedImpl _value,
      $Res Function(_$MemberUnexpectedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MemberUnexpectedImpl implements _MemberUnexpected {
  const _$MemberUnexpectedImpl();

  @override
  String toString() {
    return 'MemberFailure.unexpected()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$MemberUnexpectedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() notFound,
    required TResult Function() unableToUpdate,
    required TResult Function() unableToDelete,
  }) {
    return unexpected();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? notFound,
    TResult? Function()? unableToUpdate,
    TResult? Function()? unableToDelete,
  }) {
    return unexpected?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? notFound,
    TResult Function()? unableToUpdate,
    TResult Function()? unableToDelete,
    required TResult orElse(),
  }) {
    if (unexpected != null) {
      return unexpected();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MemberUnexpected value) unexpected,
    required TResult Function(_MemberNotFound value) notFound,
    required TResult Function(_MemberUnableToUpdate value) unableToUpdate,
    required TResult Function(_MemberUnableToDelete value) unableToDelete,
  }) {
    return unexpected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_MemberUnexpected value)? unexpected,
    TResult? Function(_MemberNotFound value)? notFound,
    TResult? Function(_MemberUnableToUpdate value)? unableToUpdate,
    TResult? Function(_MemberUnableToDelete value)? unableToDelete,
  }) {
    return unexpected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MemberUnexpected value)? unexpected,
    TResult Function(_MemberNotFound value)? notFound,
    TResult Function(_MemberUnableToUpdate value)? unableToUpdate,
    TResult Function(_MemberUnableToDelete value)? unableToDelete,
    required TResult orElse(),
  }) {
    if (unexpected != null) {
      return unexpected(this);
    }
    return orElse();
  }
}

abstract class _MemberUnexpected implements MemberFailure {
  const factory _MemberUnexpected() = _$MemberUnexpectedImpl;
}

/// @nodoc
abstract class _$$MemberNotFoundImplCopyWith<$Res> {
  factory _$$MemberNotFoundImplCopyWith(_$MemberNotFoundImpl value,
          $Res Function(_$MemberNotFoundImpl) then) =
      __$$MemberNotFoundImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MemberNotFoundImplCopyWithImpl<$Res>
    extends _$MemberFailureCopyWithImpl<$Res, _$MemberNotFoundImpl>
    implements _$$MemberNotFoundImplCopyWith<$Res> {
  __$$MemberNotFoundImplCopyWithImpl(
      _$MemberNotFoundImpl _value, $Res Function(_$MemberNotFoundImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MemberNotFoundImpl implements _MemberNotFound {
  const _$MemberNotFoundImpl();

  @override
  String toString() {
    return 'MemberFailure.notFound()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$MemberNotFoundImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() notFound,
    required TResult Function() unableToUpdate,
    required TResult Function() unableToDelete,
  }) {
    return notFound();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? notFound,
    TResult? Function()? unableToUpdate,
    TResult? Function()? unableToDelete,
  }) {
    return notFound?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? notFound,
    TResult Function()? unableToUpdate,
    TResult Function()? unableToDelete,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MemberUnexpected value) unexpected,
    required TResult Function(_MemberNotFound value) notFound,
    required TResult Function(_MemberUnableToUpdate value) unableToUpdate,
    required TResult Function(_MemberUnableToDelete value) unableToDelete,
  }) {
    return notFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_MemberUnexpected value)? unexpected,
    TResult? Function(_MemberNotFound value)? notFound,
    TResult? Function(_MemberUnableToUpdate value)? unableToUpdate,
    TResult? Function(_MemberUnableToDelete value)? unableToDelete,
  }) {
    return notFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MemberUnexpected value)? unexpected,
    TResult Function(_MemberNotFound value)? notFound,
    TResult Function(_MemberUnableToUpdate value)? unableToUpdate,
    TResult Function(_MemberUnableToDelete value)? unableToDelete,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound(this);
    }
    return orElse();
  }
}

abstract class _MemberNotFound implements MemberFailure {
  const factory _MemberNotFound() = _$MemberNotFoundImpl;
}

/// @nodoc
abstract class _$$MemberUnableToUpdateImplCopyWith<$Res> {
  factory _$$MemberUnableToUpdateImplCopyWith(_$MemberUnableToUpdateImpl value,
          $Res Function(_$MemberUnableToUpdateImpl) then) =
      __$$MemberUnableToUpdateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MemberUnableToUpdateImplCopyWithImpl<$Res>
    extends _$MemberFailureCopyWithImpl<$Res, _$MemberUnableToUpdateImpl>
    implements _$$MemberUnableToUpdateImplCopyWith<$Res> {
  __$$MemberUnableToUpdateImplCopyWithImpl(_$MemberUnableToUpdateImpl _value,
      $Res Function(_$MemberUnableToUpdateImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MemberUnableToUpdateImpl implements _MemberUnableToUpdate {
  const _$MemberUnableToUpdateImpl();

  @override
  String toString() {
    return 'MemberFailure.unableToUpdate()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MemberUnableToUpdateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() notFound,
    required TResult Function() unableToUpdate,
    required TResult Function() unableToDelete,
  }) {
    return unableToUpdate();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? notFound,
    TResult? Function()? unableToUpdate,
    TResult? Function()? unableToDelete,
  }) {
    return unableToUpdate?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? notFound,
    TResult Function()? unableToUpdate,
    TResult Function()? unableToDelete,
    required TResult orElse(),
  }) {
    if (unableToUpdate != null) {
      return unableToUpdate();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MemberUnexpected value) unexpected,
    required TResult Function(_MemberNotFound value) notFound,
    required TResult Function(_MemberUnableToUpdate value) unableToUpdate,
    required TResult Function(_MemberUnableToDelete value) unableToDelete,
  }) {
    return unableToUpdate(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_MemberUnexpected value)? unexpected,
    TResult? Function(_MemberNotFound value)? notFound,
    TResult? Function(_MemberUnableToUpdate value)? unableToUpdate,
    TResult? Function(_MemberUnableToDelete value)? unableToDelete,
  }) {
    return unableToUpdate?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MemberUnexpected value)? unexpected,
    TResult Function(_MemberNotFound value)? notFound,
    TResult Function(_MemberUnableToUpdate value)? unableToUpdate,
    TResult Function(_MemberUnableToDelete value)? unableToDelete,
    required TResult orElse(),
  }) {
    if (unableToUpdate != null) {
      return unableToUpdate(this);
    }
    return orElse();
  }
}

abstract class _MemberUnableToUpdate implements MemberFailure {
  const factory _MemberUnableToUpdate() = _$MemberUnableToUpdateImpl;
}

/// @nodoc
abstract class _$$MemberUnableToDeleteImplCopyWith<$Res> {
  factory _$$MemberUnableToDeleteImplCopyWith(_$MemberUnableToDeleteImpl value,
          $Res Function(_$MemberUnableToDeleteImpl) then) =
      __$$MemberUnableToDeleteImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MemberUnableToDeleteImplCopyWithImpl<$Res>
    extends _$MemberFailureCopyWithImpl<$Res, _$MemberUnableToDeleteImpl>
    implements _$$MemberUnableToDeleteImplCopyWith<$Res> {
  __$$MemberUnableToDeleteImplCopyWithImpl(_$MemberUnableToDeleteImpl _value,
      $Res Function(_$MemberUnableToDeleteImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MemberUnableToDeleteImpl implements _MemberUnableToDelete {
  const _$MemberUnableToDeleteImpl();

  @override
  String toString() {
    return 'MemberFailure.unableToDelete()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MemberUnableToDeleteImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() notFound,
    required TResult Function() unableToUpdate,
    required TResult Function() unableToDelete,
  }) {
    return unableToDelete();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? notFound,
    TResult? Function()? unableToUpdate,
    TResult? Function()? unableToDelete,
  }) {
    return unableToDelete?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? notFound,
    TResult Function()? unableToUpdate,
    TResult Function()? unableToDelete,
    required TResult orElse(),
  }) {
    if (unableToDelete != null) {
      return unableToDelete();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MemberUnexpected value) unexpected,
    required TResult Function(_MemberNotFound value) notFound,
    required TResult Function(_MemberUnableToUpdate value) unableToUpdate,
    required TResult Function(_MemberUnableToDelete value) unableToDelete,
  }) {
    return unableToDelete(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_MemberUnexpected value)? unexpected,
    TResult? Function(_MemberNotFound value)? notFound,
    TResult? Function(_MemberUnableToUpdate value)? unableToUpdate,
    TResult? Function(_MemberUnableToDelete value)? unableToDelete,
  }) {
    return unableToDelete?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MemberUnexpected value)? unexpected,
    TResult Function(_MemberNotFound value)? notFound,
    TResult Function(_MemberUnableToUpdate value)? unableToUpdate,
    TResult Function(_MemberUnableToDelete value)? unableToDelete,
    required TResult orElse(),
  }) {
    if (unableToDelete != null) {
      return unableToDelete(this);
    }
    return orElse();
  }
}

abstract class _MemberUnableToDelete implements MemberFailure {
  const factory _MemberUnableToDelete() = _$MemberUnableToDeleteImpl;
}

/// @nodoc
mixin _$SplitFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() serverError,
    required TResult Function() notFound,
    required TResult Function() insufficientParticipants,
    required TResult Function() debtSumNotEqualAmount,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? serverError,
    TResult? Function()? notFound,
    TResult? Function()? insufficientParticipants,
    TResult? Function()? debtSumNotEqualAmount,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? serverError,
    TResult Function()? notFound,
    TResult Function()? insufficientParticipants,
    TResult Function()? debtSumNotEqualAmount,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SplitUnexpected value) unexpected,
    required TResult Function(_SplitServerError value) serverError,
    required TResult Function(_SplitNotFound value) notFound,
    required TResult Function(_SplitInsufficientParticipants value)
        insufficientParticipants,
    required TResult Function(_SplitDebtSumNotEqualAmount value)
        debtSumNotEqualAmount,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SplitUnexpected value)? unexpected,
    TResult? Function(_SplitServerError value)? serverError,
    TResult? Function(_SplitNotFound value)? notFound,
    TResult? Function(_SplitInsufficientParticipants value)?
        insufficientParticipants,
    TResult? Function(_SplitDebtSumNotEqualAmount value)? debtSumNotEqualAmount,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SplitUnexpected value)? unexpected,
    TResult Function(_SplitServerError value)? serverError,
    TResult Function(_SplitNotFound value)? notFound,
    TResult Function(_SplitInsufficientParticipants value)?
        insufficientParticipants,
    TResult Function(_SplitDebtSumNotEqualAmount value)? debtSumNotEqualAmount,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SplitFailureCopyWith<$Res> {
  factory $SplitFailureCopyWith(
          SplitFailure value, $Res Function(SplitFailure) then) =
      _$SplitFailureCopyWithImpl<$Res, SplitFailure>;
}

/// @nodoc
class _$SplitFailureCopyWithImpl<$Res, $Val extends SplitFailure>
    implements $SplitFailureCopyWith<$Res> {
  _$SplitFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$SplitUnexpectedImplCopyWith<$Res> {
  factory _$$SplitUnexpectedImplCopyWith(_$SplitUnexpectedImpl value,
          $Res Function(_$SplitUnexpectedImpl) then) =
      __$$SplitUnexpectedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SplitUnexpectedImplCopyWithImpl<$Res>
    extends _$SplitFailureCopyWithImpl<$Res, _$SplitUnexpectedImpl>
    implements _$$SplitUnexpectedImplCopyWith<$Res> {
  __$$SplitUnexpectedImplCopyWithImpl(
      _$SplitUnexpectedImpl _value, $Res Function(_$SplitUnexpectedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SplitUnexpectedImpl implements _SplitUnexpected {
  const _$SplitUnexpectedImpl();

  @override
  String toString() {
    return 'SplitFailure.unexpected()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SplitUnexpectedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() serverError,
    required TResult Function() notFound,
    required TResult Function() insufficientParticipants,
    required TResult Function() debtSumNotEqualAmount,
  }) {
    return unexpected();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? serverError,
    TResult? Function()? notFound,
    TResult? Function()? insufficientParticipants,
    TResult? Function()? debtSumNotEqualAmount,
  }) {
    return unexpected?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? serverError,
    TResult Function()? notFound,
    TResult Function()? insufficientParticipants,
    TResult Function()? debtSumNotEqualAmount,
    required TResult orElse(),
  }) {
    if (unexpected != null) {
      return unexpected();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SplitUnexpected value) unexpected,
    required TResult Function(_SplitServerError value) serverError,
    required TResult Function(_SplitNotFound value) notFound,
    required TResult Function(_SplitInsufficientParticipants value)
        insufficientParticipants,
    required TResult Function(_SplitDebtSumNotEqualAmount value)
        debtSumNotEqualAmount,
  }) {
    return unexpected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SplitUnexpected value)? unexpected,
    TResult? Function(_SplitServerError value)? serverError,
    TResult? Function(_SplitNotFound value)? notFound,
    TResult? Function(_SplitInsufficientParticipants value)?
        insufficientParticipants,
    TResult? Function(_SplitDebtSumNotEqualAmount value)? debtSumNotEqualAmount,
  }) {
    return unexpected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SplitUnexpected value)? unexpected,
    TResult Function(_SplitServerError value)? serverError,
    TResult Function(_SplitNotFound value)? notFound,
    TResult Function(_SplitInsufficientParticipants value)?
        insufficientParticipants,
    TResult Function(_SplitDebtSumNotEqualAmount value)? debtSumNotEqualAmount,
    required TResult orElse(),
  }) {
    if (unexpected != null) {
      return unexpected(this);
    }
    return orElse();
  }
}

abstract class _SplitUnexpected implements SplitFailure {
  const factory _SplitUnexpected() = _$SplitUnexpectedImpl;
}

/// @nodoc
abstract class _$$SplitServerErrorImplCopyWith<$Res> {
  factory _$$SplitServerErrorImplCopyWith(_$SplitServerErrorImpl value,
          $Res Function(_$SplitServerErrorImpl) then) =
      __$$SplitServerErrorImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SplitServerErrorImplCopyWithImpl<$Res>
    extends _$SplitFailureCopyWithImpl<$Res, _$SplitServerErrorImpl>
    implements _$$SplitServerErrorImplCopyWith<$Res> {
  __$$SplitServerErrorImplCopyWithImpl(_$SplitServerErrorImpl _value,
      $Res Function(_$SplitServerErrorImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SplitServerErrorImpl implements _SplitServerError {
  const _$SplitServerErrorImpl();

  @override
  String toString() {
    return 'SplitFailure.serverError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SplitServerErrorImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() serverError,
    required TResult Function() notFound,
    required TResult Function() insufficientParticipants,
    required TResult Function() debtSumNotEqualAmount,
  }) {
    return serverError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? serverError,
    TResult? Function()? notFound,
    TResult? Function()? insufficientParticipants,
    TResult? Function()? debtSumNotEqualAmount,
  }) {
    return serverError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? serverError,
    TResult Function()? notFound,
    TResult Function()? insufficientParticipants,
    TResult Function()? debtSumNotEqualAmount,
    required TResult orElse(),
  }) {
    if (serverError != null) {
      return serverError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SplitUnexpected value) unexpected,
    required TResult Function(_SplitServerError value) serverError,
    required TResult Function(_SplitNotFound value) notFound,
    required TResult Function(_SplitInsufficientParticipants value)
        insufficientParticipants,
    required TResult Function(_SplitDebtSumNotEqualAmount value)
        debtSumNotEqualAmount,
  }) {
    return serverError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SplitUnexpected value)? unexpected,
    TResult? Function(_SplitServerError value)? serverError,
    TResult? Function(_SplitNotFound value)? notFound,
    TResult? Function(_SplitInsufficientParticipants value)?
        insufficientParticipants,
    TResult? Function(_SplitDebtSumNotEqualAmount value)? debtSumNotEqualAmount,
  }) {
    return serverError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SplitUnexpected value)? unexpected,
    TResult Function(_SplitServerError value)? serverError,
    TResult Function(_SplitNotFound value)? notFound,
    TResult Function(_SplitInsufficientParticipants value)?
        insufficientParticipants,
    TResult Function(_SplitDebtSumNotEqualAmount value)? debtSumNotEqualAmount,
    required TResult orElse(),
  }) {
    if (serverError != null) {
      return serverError(this);
    }
    return orElse();
  }
}

abstract class _SplitServerError implements SplitFailure {
  const factory _SplitServerError() = _$SplitServerErrorImpl;
}

/// @nodoc
abstract class _$$SplitNotFoundImplCopyWith<$Res> {
  factory _$$SplitNotFoundImplCopyWith(
          _$SplitNotFoundImpl value, $Res Function(_$SplitNotFoundImpl) then) =
      __$$SplitNotFoundImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SplitNotFoundImplCopyWithImpl<$Res>
    extends _$SplitFailureCopyWithImpl<$Res, _$SplitNotFoundImpl>
    implements _$$SplitNotFoundImplCopyWith<$Res> {
  __$$SplitNotFoundImplCopyWithImpl(
      _$SplitNotFoundImpl _value, $Res Function(_$SplitNotFoundImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SplitNotFoundImpl implements _SplitNotFound {
  const _$SplitNotFoundImpl();

  @override
  String toString() {
    return 'SplitFailure.notFound()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SplitNotFoundImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() serverError,
    required TResult Function() notFound,
    required TResult Function() insufficientParticipants,
    required TResult Function() debtSumNotEqualAmount,
  }) {
    return notFound();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? serverError,
    TResult? Function()? notFound,
    TResult? Function()? insufficientParticipants,
    TResult? Function()? debtSumNotEqualAmount,
  }) {
    return notFound?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? serverError,
    TResult Function()? notFound,
    TResult Function()? insufficientParticipants,
    TResult Function()? debtSumNotEqualAmount,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SplitUnexpected value) unexpected,
    required TResult Function(_SplitServerError value) serverError,
    required TResult Function(_SplitNotFound value) notFound,
    required TResult Function(_SplitInsufficientParticipants value)
        insufficientParticipants,
    required TResult Function(_SplitDebtSumNotEqualAmount value)
        debtSumNotEqualAmount,
  }) {
    return notFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SplitUnexpected value)? unexpected,
    TResult? Function(_SplitServerError value)? serverError,
    TResult? Function(_SplitNotFound value)? notFound,
    TResult? Function(_SplitInsufficientParticipants value)?
        insufficientParticipants,
    TResult? Function(_SplitDebtSumNotEqualAmount value)? debtSumNotEqualAmount,
  }) {
    return notFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SplitUnexpected value)? unexpected,
    TResult Function(_SplitServerError value)? serverError,
    TResult Function(_SplitNotFound value)? notFound,
    TResult Function(_SplitInsufficientParticipants value)?
        insufficientParticipants,
    TResult Function(_SplitDebtSumNotEqualAmount value)? debtSumNotEqualAmount,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound(this);
    }
    return orElse();
  }
}

abstract class _SplitNotFound implements SplitFailure {
  const factory _SplitNotFound() = _$SplitNotFoundImpl;
}

/// @nodoc
abstract class _$$SplitInsufficientParticipantsImplCopyWith<$Res> {
  factory _$$SplitInsufficientParticipantsImplCopyWith(
          _$SplitInsufficientParticipantsImpl value,
          $Res Function(_$SplitInsufficientParticipantsImpl) then) =
      __$$SplitInsufficientParticipantsImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SplitInsufficientParticipantsImplCopyWithImpl<$Res>
    extends _$SplitFailureCopyWithImpl<$Res,
        _$SplitInsufficientParticipantsImpl>
    implements _$$SplitInsufficientParticipantsImplCopyWith<$Res> {
  __$$SplitInsufficientParticipantsImplCopyWithImpl(
      _$SplitInsufficientParticipantsImpl _value,
      $Res Function(_$SplitInsufficientParticipantsImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SplitInsufficientParticipantsImpl
    implements _SplitInsufficientParticipants {
  const _$SplitInsufficientParticipantsImpl();

  @override
  String toString() {
    return 'SplitFailure.insufficientParticipants()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SplitInsufficientParticipantsImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() serverError,
    required TResult Function() notFound,
    required TResult Function() insufficientParticipants,
    required TResult Function() debtSumNotEqualAmount,
  }) {
    return insufficientParticipants();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? serverError,
    TResult? Function()? notFound,
    TResult? Function()? insufficientParticipants,
    TResult? Function()? debtSumNotEqualAmount,
  }) {
    return insufficientParticipants?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? serverError,
    TResult Function()? notFound,
    TResult Function()? insufficientParticipants,
    TResult Function()? debtSumNotEqualAmount,
    required TResult orElse(),
  }) {
    if (insufficientParticipants != null) {
      return insufficientParticipants();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SplitUnexpected value) unexpected,
    required TResult Function(_SplitServerError value) serverError,
    required TResult Function(_SplitNotFound value) notFound,
    required TResult Function(_SplitInsufficientParticipants value)
        insufficientParticipants,
    required TResult Function(_SplitDebtSumNotEqualAmount value)
        debtSumNotEqualAmount,
  }) {
    return insufficientParticipants(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SplitUnexpected value)? unexpected,
    TResult? Function(_SplitServerError value)? serverError,
    TResult? Function(_SplitNotFound value)? notFound,
    TResult? Function(_SplitInsufficientParticipants value)?
        insufficientParticipants,
    TResult? Function(_SplitDebtSumNotEqualAmount value)? debtSumNotEqualAmount,
  }) {
    return insufficientParticipants?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SplitUnexpected value)? unexpected,
    TResult Function(_SplitServerError value)? serverError,
    TResult Function(_SplitNotFound value)? notFound,
    TResult Function(_SplitInsufficientParticipants value)?
        insufficientParticipants,
    TResult Function(_SplitDebtSumNotEqualAmount value)? debtSumNotEqualAmount,
    required TResult orElse(),
  }) {
    if (insufficientParticipants != null) {
      return insufficientParticipants(this);
    }
    return orElse();
  }
}

abstract class _SplitInsufficientParticipants implements SplitFailure {
  const factory _SplitInsufficientParticipants() =
      _$SplitInsufficientParticipantsImpl;
}

/// @nodoc
abstract class _$$SplitDebtSumNotEqualAmountImplCopyWith<$Res> {
  factory _$$SplitDebtSumNotEqualAmountImplCopyWith(
          _$SplitDebtSumNotEqualAmountImpl value,
          $Res Function(_$SplitDebtSumNotEqualAmountImpl) then) =
      __$$SplitDebtSumNotEqualAmountImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SplitDebtSumNotEqualAmountImplCopyWithImpl<$Res>
    extends _$SplitFailureCopyWithImpl<$Res, _$SplitDebtSumNotEqualAmountImpl>
    implements _$$SplitDebtSumNotEqualAmountImplCopyWith<$Res> {
  __$$SplitDebtSumNotEqualAmountImplCopyWithImpl(
      _$SplitDebtSumNotEqualAmountImpl _value,
      $Res Function(_$SplitDebtSumNotEqualAmountImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SplitDebtSumNotEqualAmountImpl implements _SplitDebtSumNotEqualAmount {
  const _$SplitDebtSumNotEqualAmountImpl();

  @override
  String toString() {
    return 'SplitFailure.debtSumNotEqualAmount()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SplitDebtSumNotEqualAmountImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() serverError,
    required TResult Function() notFound,
    required TResult Function() insufficientParticipants,
    required TResult Function() debtSumNotEqualAmount,
  }) {
    return debtSumNotEqualAmount();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? serverError,
    TResult? Function()? notFound,
    TResult? Function()? insufficientParticipants,
    TResult? Function()? debtSumNotEqualAmount,
  }) {
    return debtSumNotEqualAmount?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? serverError,
    TResult Function()? notFound,
    TResult Function()? insufficientParticipants,
    TResult Function()? debtSumNotEqualAmount,
    required TResult orElse(),
  }) {
    if (debtSumNotEqualAmount != null) {
      return debtSumNotEqualAmount();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SplitUnexpected value) unexpected,
    required TResult Function(_SplitServerError value) serverError,
    required TResult Function(_SplitNotFound value) notFound,
    required TResult Function(_SplitInsufficientParticipants value)
        insufficientParticipants,
    required TResult Function(_SplitDebtSumNotEqualAmount value)
        debtSumNotEqualAmount,
  }) {
    return debtSumNotEqualAmount(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SplitUnexpected value)? unexpected,
    TResult? Function(_SplitServerError value)? serverError,
    TResult? Function(_SplitNotFound value)? notFound,
    TResult? Function(_SplitInsufficientParticipants value)?
        insufficientParticipants,
    TResult? Function(_SplitDebtSumNotEqualAmount value)? debtSumNotEqualAmount,
  }) {
    return debtSumNotEqualAmount?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SplitUnexpected value)? unexpected,
    TResult Function(_SplitServerError value)? serverError,
    TResult Function(_SplitNotFound value)? notFound,
    TResult Function(_SplitInsufficientParticipants value)?
        insufficientParticipants,
    TResult Function(_SplitDebtSumNotEqualAmount value)? debtSumNotEqualAmount,
    required TResult orElse(),
  }) {
    if (debtSumNotEqualAmount != null) {
      return debtSumNotEqualAmount(this);
    }
    return orElse();
  }
}

abstract class _SplitDebtSumNotEqualAmount implements SplitFailure {
  const factory _SplitDebtSumNotEqualAmount() =
      _$SplitDebtSumNotEqualAmountImpl;
}
