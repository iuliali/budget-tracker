// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$GroupFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() notFound,
    required TResult Function() groupAlreadyExists,
    required TResult Function() unableToUpdate,
    required TResult Function() unableToDelete,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? notFound,
    TResult? Function()? groupAlreadyExists,
    TResult? Function()? unableToUpdate,
    TResult? Function()? unableToDelete,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? notFound,
    TResult Function()? groupAlreadyExists,
    TResult Function()? unableToUpdate,
    TResult Function()? unableToDelete,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GroupUnexpected value) unexpected,
    required TResult Function(_GroupNotFound value) notFound,
    required TResult Function(_GroupAlreadyExists value) groupAlreadyExists,
    required TResult Function(_GroupUnableToUpdate value) unableToUpdate,
    required TResult Function(_GroupUnableToDelete value) unableToDelete,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GroupUnexpected value)? unexpected,
    TResult? Function(_GroupNotFound value)? notFound,
    TResult? Function(_GroupAlreadyExists value)? groupAlreadyExists,
    TResult? Function(_GroupUnableToUpdate value)? unableToUpdate,
    TResult? Function(_GroupUnableToDelete value)? unableToDelete,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GroupUnexpected value)? unexpected,
    TResult Function(_GroupNotFound value)? notFound,
    TResult Function(_GroupAlreadyExists value)? groupAlreadyExists,
    TResult Function(_GroupUnableToUpdate value)? unableToUpdate,
    TResult Function(_GroupUnableToDelete value)? unableToDelete,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GroupFailureCopyWith<$Res> {
  factory $GroupFailureCopyWith(
          GroupFailure value, $Res Function(GroupFailure) then) =
      _$GroupFailureCopyWithImpl<$Res, GroupFailure>;
}

/// @nodoc
class _$GroupFailureCopyWithImpl<$Res, $Val extends GroupFailure>
    implements $GroupFailureCopyWith<$Res> {
  _$GroupFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_GroupUnexpectedCopyWith<$Res> {
  factory _$$_GroupUnexpectedCopyWith(
          _$_GroupUnexpected value, $Res Function(_$_GroupUnexpected) then) =
      __$$_GroupUnexpectedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_GroupUnexpectedCopyWithImpl<$Res>
    extends _$GroupFailureCopyWithImpl<$Res, _$_GroupUnexpected>
    implements _$$_GroupUnexpectedCopyWith<$Res> {
  __$$_GroupUnexpectedCopyWithImpl(
      _$_GroupUnexpected _value, $Res Function(_$_GroupUnexpected) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_GroupUnexpected implements _GroupUnexpected {
  const _$_GroupUnexpected();

  @override
  String toString() {
    return 'GroupFailure.unexpected()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_GroupUnexpected);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() notFound,
    required TResult Function() groupAlreadyExists,
    required TResult Function() unableToUpdate,
    required TResult Function() unableToDelete,
  }) {
    return unexpected();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? notFound,
    TResult? Function()? groupAlreadyExists,
    TResult? Function()? unableToUpdate,
    TResult? Function()? unableToDelete,
  }) {
    return unexpected?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? notFound,
    TResult Function()? groupAlreadyExists,
    TResult Function()? unableToUpdate,
    TResult Function()? unableToDelete,
    required TResult orElse(),
  }) {
    if (unexpected != null) {
      return unexpected();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GroupUnexpected value) unexpected,
    required TResult Function(_GroupNotFound value) notFound,
    required TResult Function(_GroupAlreadyExists value) groupAlreadyExists,
    required TResult Function(_GroupUnableToUpdate value) unableToUpdate,
    required TResult Function(_GroupUnableToDelete value) unableToDelete,
  }) {
    return unexpected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GroupUnexpected value)? unexpected,
    TResult? Function(_GroupNotFound value)? notFound,
    TResult? Function(_GroupAlreadyExists value)? groupAlreadyExists,
    TResult? Function(_GroupUnableToUpdate value)? unableToUpdate,
    TResult? Function(_GroupUnableToDelete value)? unableToDelete,
  }) {
    return unexpected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GroupUnexpected value)? unexpected,
    TResult Function(_GroupNotFound value)? notFound,
    TResult Function(_GroupAlreadyExists value)? groupAlreadyExists,
    TResult Function(_GroupUnableToUpdate value)? unableToUpdate,
    TResult Function(_GroupUnableToDelete value)? unableToDelete,
    required TResult orElse(),
  }) {
    if (unexpected != null) {
      return unexpected(this);
    }
    return orElse();
  }
}

abstract class _GroupUnexpected implements GroupFailure {
  const factory _GroupUnexpected() = _$_GroupUnexpected;
}

/// @nodoc
abstract class _$$_GroupNotFoundCopyWith<$Res> {
  factory _$$_GroupNotFoundCopyWith(
          _$_GroupNotFound value, $Res Function(_$_GroupNotFound) then) =
      __$$_GroupNotFoundCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_GroupNotFoundCopyWithImpl<$Res>
    extends _$GroupFailureCopyWithImpl<$Res, _$_GroupNotFound>
    implements _$$_GroupNotFoundCopyWith<$Res> {
  __$$_GroupNotFoundCopyWithImpl(
      _$_GroupNotFound _value, $Res Function(_$_GroupNotFound) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_GroupNotFound implements _GroupNotFound {
  const _$_GroupNotFound();

  @override
  String toString() {
    return 'GroupFailure.notFound()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_GroupNotFound);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() notFound,
    required TResult Function() groupAlreadyExists,
    required TResult Function() unableToUpdate,
    required TResult Function() unableToDelete,
  }) {
    return notFound();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? notFound,
    TResult? Function()? groupAlreadyExists,
    TResult? Function()? unableToUpdate,
    TResult? Function()? unableToDelete,
  }) {
    return notFound?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? notFound,
    TResult Function()? groupAlreadyExists,
    TResult Function()? unableToUpdate,
    TResult Function()? unableToDelete,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GroupUnexpected value) unexpected,
    required TResult Function(_GroupNotFound value) notFound,
    required TResult Function(_GroupAlreadyExists value) groupAlreadyExists,
    required TResult Function(_GroupUnableToUpdate value) unableToUpdate,
    required TResult Function(_GroupUnableToDelete value) unableToDelete,
  }) {
    return notFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GroupUnexpected value)? unexpected,
    TResult? Function(_GroupNotFound value)? notFound,
    TResult? Function(_GroupAlreadyExists value)? groupAlreadyExists,
    TResult? Function(_GroupUnableToUpdate value)? unableToUpdate,
    TResult? Function(_GroupUnableToDelete value)? unableToDelete,
  }) {
    return notFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GroupUnexpected value)? unexpected,
    TResult Function(_GroupNotFound value)? notFound,
    TResult Function(_GroupAlreadyExists value)? groupAlreadyExists,
    TResult Function(_GroupUnableToUpdate value)? unableToUpdate,
    TResult Function(_GroupUnableToDelete value)? unableToDelete,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound(this);
    }
    return orElse();
  }
}

abstract class _GroupNotFound implements GroupFailure {
  const factory _GroupNotFound() = _$_GroupNotFound;
}

/// @nodoc
abstract class _$$_GroupAlreadyExistsCopyWith<$Res> {
  factory _$$_GroupAlreadyExistsCopyWith(_$_GroupAlreadyExists value,
          $Res Function(_$_GroupAlreadyExists) then) =
      __$$_GroupAlreadyExistsCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_GroupAlreadyExistsCopyWithImpl<$Res>
    extends _$GroupFailureCopyWithImpl<$Res, _$_GroupAlreadyExists>
    implements _$$_GroupAlreadyExistsCopyWith<$Res> {
  __$$_GroupAlreadyExistsCopyWithImpl(
      _$_GroupAlreadyExists _value, $Res Function(_$_GroupAlreadyExists) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_GroupAlreadyExists implements _GroupAlreadyExists {
  const _$_GroupAlreadyExists();

  @override
  String toString() {
    return 'GroupFailure.groupAlreadyExists()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_GroupAlreadyExists);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() notFound,
    required TResult Function() groupAlreadyExists,
    required TResult Function() unableToUpdate,
    required TResult Function() unableToDelete,
  }) {
    return groupAlreadyExists();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? notFound,
    TResult? Function()? groupAlreadyExists,
    TResult? Function()? unableToUpdate,
    TResult? Function()? unableToDelete,
  }) {
    return groupAlreadyExists?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? notFound,
    TResult Function()? groupAlreadyExists,
    TResult Function()? unableToUpdate,
    TResult Function()? unableToDelete,
    required TResult orElse(),
  }) {
    if (groupAlreadyExists != null) {
      return groupAlreadyExists();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GroupUnexpected value) unexpected,
    required TResult Function(_GroupNotFound value) notFound,
    required TResult Function(_GroupAlreadyExists value) groupAlreadyExists,
    required TResult Function(_GroupUnableToUpdate value) unableToUpdate,
    required TResult Function(_GroupUnableToDelete value) unableToDelete,
  }) {
    return groupAlreadyExists(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GroupUnexpected value)? unexpected,
    TResult? Function(_GroupNotFound value)? notFound,
    TResult? Function(_GroupAlreadyExists value)? groupAlreadyExists,
    TResult? Function(_GroupUnableToUpdate value)? unableToUpdate,
    TResult? Function(_GroupUnableToDelete value)? unableToDelete,
  }) {
    return groupAlreadyExists?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GroupUnexpected value)? unexpected,
    TResult Function(_GroupNotFound value)? notFound,
    TResult Function(_GroupAlreadyExists value)? groupAlreadyExists,
    TResult Function(_GroupUnableToUpdate value)? unableToUpdate,
    TResult Function(_GroupUnableToDelete value)? unableToDelete,
    required TResult orElse(),
  }) {
    if (groupAlreadyExists != null) {
      return groupAlreadyExists(this);
    }
    return orElse();
  }
}

abstract class _GroupAlreadyExists implements GroupFailure {
  const factory _GroupAlreadyExists() = _$_GroupAlreadyExists;
}

/// @nodoc
abstract class _$$_GroupUnableToUpdateCopyWith<$Res> {
  factory _$$_GroupUnableToUpdateCopyWith(_$_GroupUnableToUpdate value,
          $Res Function(_$_GroupUnableToUpdate) then) =
      __$$_GroupUnableToUpdateCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_GroupUnableToUpdateCopyWithImpl<$Res>
    extends _$GroupFailureCopyWithImpl<$Res, _$_GroupUnableToUpdate>
    implements _$$_GroupUnableToUpdateCopyWith<$Res> {
  __$$_GroupUnableToUpdateCopyWithImpl(_$_GroupUnableToUpdate _value,
      $Res Function(_$_GroupUnableToUpdate) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_GroupUnableToUpdate implements _GroupUnableToUpdate {
  const _$_GroupUnableToUpdate();

  @override
  String toString() {
    return 'GroupFailure.unableToUpdate()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_GroupUnableToUpdate);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() notFound,
    required TResult Function() groupAlreadyExists,
    required TResult Function() unableToUpdate,
    required TResult Function() unableToDelete,
  }) {
    return unableToUpdate();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? notFound,
    TResult? Function()? groupAlreadyExists,
    TResult? Function()? unableToUpdate,
    TResult? Function()? unableToDelete,
  }) {
    return unableToUpdate?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? notFound,
    TResult Function()? groupAlreadyExists,
    TResult Function()? unableToUpdate,
    TResult Function()? unableToDelete,
    required TResult orElse(),
  }) {
    if (unableToUpdate != null) {
      return unableToUpdate();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GroupUnexpected value) unexpected,
    required TResult Function(_GroupNotFound value) notFound,
    required TResult Function(_GroupAlreadyExists value) groupAlreadyExists,
    required TResult Function(_GroupUnableToUpdate value) unableToUpdate,
    required TResult Function(_GroupUnableToDelete value) unableToDelete,
  }) {
    return unableToUpdate(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GroupUnexpected value)? unexpected,
    TResult? Function(_GroupNotFound value)? notFound,
    TResult? Function(_GroupAlreadyExists value)? groupAlreadyExists,
    TResult? Function(_GroupUnableToUpdate value)? unableToUpdate,
    TResult? Function(_GroupUnableToDelete value)? unableToDelete,
  }) {
    return unableToUpdate?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GroupUnexpected value)? unexpected,
    TResult Function(_GroupNotFound value)? notFound,
    TResult Function(_GroupAlreadyExists value)? groupAlreadyExists,
    TResult Function(_GroupUnableToUpdate value)? unableToUpdate,
    TResult Function(_GroupUnableToDelete value)? unableToDelete,
    required TResult orElse(),
  }) {
    if (unableToUpdate != null) {
      return unableToUpdate(this);
    }
    return orElse();
  }
}

abstract class _GroupUnableToUpdate implements GroupFailure {
  const factory _GroupUnableToUpdate() = _$_GroupUnableToUpdate;
}

/// @nodoc
abstract class _$$_GroupUnableToDeleteCopyWith<$Res> {
  factory _$$_GroupUnableToDeleteCopyWith(_$_GroupUnableToDelete value,
          $Res Function(_$_GroupUnableToDelete) then) =
      __$$_GroupUnableToDeleteCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_GroupUnableToDeleteCopyWithImpl<$Res>
    extends _$GroupFailureCopyWithImpl<$Res, _$_GroupUnableToDelete>
    implements _$$_GroupUnableToDeleteCopyWith<$Res> {
  __$$_GroupUnableToDeleteCopyWithImpl(_$_GroupUnableToDelete _value,
      $Res Function(_$_GroupUnableToDelete) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_GroupUnableToDelete implements _GroupUnableToDelete {
  const _$_GroupUnableToDelete();

  @override
  String toString() {
    return 'GroupFailure.unableToDelete()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_GroupUnableToDelete);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() notFound,
    required TResult Function() groupAlreadyExists,
    required TResult Function() unableToUpdate,
    required TResult Function() unableToDelete,
  }) {
    return unableToDelete();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? notFound,
    TResult? Function()? groupAlreadyExists,
    TResult? Function()? unableToUpdate,
    TResult? Function()? unableToDelete,
  }) {
    return unableToDelete?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? notFound,
    TResult Function()? groupAlreadyExists,
    TResult Function()? unableToUpdate,
    TResult Function()? unableToDelete,
    required TResult orElse(),
  }) {
    if (unableToDelete != null) {
      return unableToDelete();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GroupUnexpected value) unexpected,
    required TResult Function(_GroupNotFound value) notFound,
    required TResult Function(_GroupAlreadyExists value) groupAlreadyExists,
    required TResult Function(_GroupUnableToUpdate value) unableToUpdate,
    required TResult Function(_GroupUnableToDelete value) unableToDelete,
  }) {
    return unableToDelete(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GroupUnexpected value)? unexpected,
    TResult? Function(_GroupNotFound value)? notFound,
    TResult? Function(_GroupAlreadyExists value)? groupAlreadyExists,
    TResult? Function(_GroupUnableToUpdate value)? unableToUpdate,
    TResult? Function(_GroupUnableToDelete value)? unableToDelete,
  }) {
    return unableToDelete?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GroupUnexpected value)? unexpected,
    TResult Function(_GroupNotFound value)? notFound,
    TResult Function(_GroupAlreadyExists value)? groupAlreadyExists,
    TResult Function(_GroupUnableToUpdate value)? unableToUpdate,
    TResult Function(_GroupUnableToDelete value)? unableToDelete,
    required TResult orElse(),
  }) {
    if (unableToDelete != null) {
      return unableToDelete(this);
    }
    return orElse();
  }
}

abstract class _GroupUnableToDelete implements GroupFailure {
  const factory _GroupUnableToDelete() = _$_GroupUnableToDelete;
}

/// @nodoc
mixin _$MemberFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() notFound,
    required TResult Function() unableToUpdate,
    required TResult Function() unableToDelete,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? notFound,
    TResult? Function()? unableToUpdate,
    TResult? Function()? unableToDelete,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? notFound,
    TResult Function()? unableToUpdate,
    TResult Function()? unableToDelete,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MemberUnexpected value) unexpected,
    required TResult Function(_MemberNotFound value) notFound,
    required TResult Function(_MemberUnableToUpdate value) unableToUpdate,
    required TResult Function(_MemberUnableToDelete value) unableToDelete,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_MemberUnexpected value)? unexpected,
    TResult? Function(_MemberNotFound value)? notFound,
    TResult? Function(_MemberUnableToUpdate value)? unableToUpdate,
    TResult? Function(_MemberUnableToDelete value)? unableToDelete,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MemberUnexpected value)? unexpected,
    TResult Function(_MemberNotFound value)? notFound,
    TResult Function(_MemberUnableToUpdate value)? unableToUpdate,
    TResult Function(_MemberUnableToDelete value)? unableToDelete,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MemberFailureCopyWith<$Res> {
  factory $MemberFailureCopyWith(
          MemberFailure value, $Res Function(MemberFailure) then) =
      _$MemberFailureCopyWithImpl<$Res, MemberFailure>;
}

/// @nodoc
class _$MemberFailureCopyWithImpl<$Res, $Val extends MemberFailure>
    implements $MemberFailureCopyWith<$Res> {
  _$MemberFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_MemberUnexpectedCopyWith<$Res> {
  factory _$$_MemberUnexpectedCopyWith(
          _$_MemberUnexpected value, $Res Function(_$_MemberUnexpected) then) =
      __$$_MemberUnexpectedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_MemberUnexpectedCopyWithImpl<$Res>
    extends _$MemberFailureCopyWithImpl<$Res, _$_MemberUnexpected>
    implements _$$_MemberUnexpectedCopyWith<$Res> {
  __$$_MemberUnexpectedCopyWithImpl(
      _$_MemberUnexpected _value, $Res Function(_$_MemberUnexpected) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_MemberUnexpected implements _MemberUnexpected {
  const _$_MemberUnexpected();

  @override
  String toString() {
    return 'MemberFailure.unexpected()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_MemberUnexpected);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() notFound,
    required TResult Function() unableToUpdate,
    required TResult Function() unableToDelete,
  }) {
    return unexpected();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? notFound,
    TResult? Function()? unableToUpdate,
    TResult? Function()? unableToDelete,
  }) {
    return unexpected?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? notFound,
    TResult Function()? unableToUpdate,
    TResult Function()? unableToDelete,
    required TResult orElse(),
  }) {
    if (unexpected != null) {
      return unexpected();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MemberUnexpected value) unexpected,
    required TResult Function(_MemberNotFound value) notFound,
    required TResult Function(_MemberUnableToUpdate value) unableToUpdate,
    required TResult Function(_MemberUnableToDelete value) unableToDelete,
  }) {
    return unexpected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_MemberUnexpected value)? unexpected,
    TResult? Function(_MemberNotFound value)? notFound,
    TResult? Function(_MemberUnableToUpdate value)? unableToUpdate,
    TResult? Function(_MemberUnableToDelete value)? unableToDelete,
  }) {
    return unexpected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MemberUnexpected value)? unexpected,
    TResult Function(_MemberNotFound value)? notFound,
    TResult Function(_MemberUnableToUpdate value)? unableToUpdate,
    TResult Function(_MemberUnableToDelete value)? unableToDelete,
    required TResult orElse(),
  }) {
    if (unexpected != null) {
      return unexpected(this);
    }
    return orElse();
  }
}

abstract class _MemberUnexpected implements MemberFailure {
  const factory _MemberUnexpected() = _$_MemberUnexpected;
}

/// @nodoc
abstract class _$$_MemberNotFoundCopyWith<$Res> {
  factory _$$_MemberNotFoundCopyWith(
          _$_MemberNotFound value, $Res Function(_$_MemberNotFound) then) =
      __$$_MemberNotFoundCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_MemberNotFoundCopyWithImpl<$Res>
    extends _$MemberFailureCopyWithImpl<$Res, _$_MemberNotFound>
    implements _$$_MemberNotFoundCopyWith<$Res> {
  __$$_MemberNotFoundCopyWithImpl(
      _$_MemberNotFound _value, $Res Function(_$_MemberNotFound) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_MemberNotFound implements _MemberNotFound {
  const _$_MemberNotFound();

  @override
  String toString() {
    return 'MemberFailure.notFound()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_MemberNotFound);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() notFound,
    required TResult Function() unableToUpdate,
    required TResult Function() unableToDelete,
  }) {
    return notFound();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? notFound,
    TResult? Function()? unableToUpdate,
    TResult? Function()? unableToDelete,
  }) {
    return notFound?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? notFound,
    TResult Function()? unableToUpdate,
    TResult Function()? unableToDelete,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MemberUnexpected value) unexpected,
    required TResult Function(_MemberNotFound value) notFound,
    required TResult Function(_MemberUnableToUpdate value) unableToUpdate,
    required TResult Function(_MemberUnableToDelete value) unableToDelete,
  }) {
    return notFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_MemberUnexpected value)? unexpected,
    TResult? Function(_MemberNotFound value)? notFound,
    TResult? Function(_MemberUnableToUpdate value)? unableToUpdate,
    TResult? Function(_MemberUnableToDelete value)? unableToDelete,
  }) {
    return notFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MemberUnexpected value)? unexpected,
    TResult Function(_MemberNotFound value)? notFound,
    TResult Function(_MemberUnableToUpdate value)? unableToUpdate,
    TResult Function(_MemberUnableToDelete value)? unableToDelete,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound(this);
    }
    return orElse();
  }
}

abstract class _MemberNotFound implements MemberFailure {
  const factory _MemberNotFound() = _$_MemberNotFound;
}

/// @nodoc
abstract class _$$_MemberUnableToUpdateCopyWith<$Res> {
  factory _$$_MemberUnableToUpdateCopyWith(_$_MemberUnableToUpdate value,
          $Res Function(_$_MemberUnableToUpdate) then) =
      __$$_MemberUnableToUpdateCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_MemberUnableToUpdateCopyWithImpl<$Res>
    extends _$MemberFailureCopyWithImpl<$Res, _$_MemberUnableToUpdate>
    implements _$$_MemberUnableToUpdateCopyWith<$Res> {
  __$$_MemberUnableToUpdateCopyWithImpl(_$_MemberUnableToUpdate _value,
      $Res Function(_$_MemberUnableToUpdate) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_MemberUnableToUpdate implements _MemberUnableToUpdate {
  const _$_MemberUnableToUpdate();

  @override
  String toString() {
    return 'MemberFailure.unableToUpdate()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_MemberUnableToUpdate);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() notFound,
    required TResult Function() unableToUpdate,
    required TResult Function() unableToDelete,
  }) {
    return unableToUpdate();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? notFound,
    TResult? Function()? unableToUpdate,
    TResult? Function()? unableToDelete,
  }) {
    return unableToUpdate?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? notFound,
    TResult Function()? unableToUpdate,
    TResult Function()? unableToDelete,
    required TResult orElse(),
  }) {
    if (unableToUpdate != null) {
      return unableToUpdate();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MemberUnexpected value) unexpected,
    required TResult Function(_MemberNotFound value) notFound,
    required TResult Function(_MemberUnableToUpdate value) unableToUpdate,
    required TResult Function(_MemberUnableToDelete value) unableToDelete,
  }) {
    return unableToUpdate(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_MemberUnexpected value)? unexpected,
    TResult? Function(_MemberNotFound value)? notFound,
    TResult? Function(_MemberUnableToUpdate value)? unableToUpdate,
    TResult? Function(_MemberUnableToDelete value)? unableToDelete,
  }) {
    return unableToUpdate?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MemberUnexpected value)? unexpected,
    TResult Function(_MemberNotFound value)? notFound,
    TResult Function(_MemberUnableToUpdate value)? unableToUpdate,
    TResult Function(_MemberUnableToDelete value)? unableToDelete,
    required TResult orElse(),
  }) {
    if (unableToUpdate != null) {
      return unableToUpdate(this);
    }
    return orElse();
  }
}

abstract class _MemberUnableToUpdate implements MemberFailure {
  const factory _MemberUnableToUpdate() = _$_MemberUnableToUpdate;
}

/// @nodoc
abstract class _$$_MemberUnableToDeleteCopyWith<$Res> {
  factory _$$_MemberUnableToDeleteCopyWith(_$_MemberUnableToDelete value,
          $Res Function(_$_MemberUnableToDelete) then) =
      __$$_MemberUnableToDeleteCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_MemberUnableToDeleteCopyWithImpl<$Res>
    extends _$MemberFailureCopyWithImpl<$Res, _$_MemberUnableToDelete>
    implements _$$_MemberUnableToDeleteCopyWith<$Res> {
  __$$_MemberUnableToDeleteCopyWithImpl(_$_MemberUnableToDelete _value,
      $Res Function(_$_MemberUnableToDelete) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_MemberUnableToDelete implements _MemberUnableToDelete {
  const _$_MemberUnableToDelete();

  @override
  String toString() {
    return 'MemberFailure.unableToDelete()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_MemberUnableToDelete);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() notFound,
    required TResult Function() unableToUpdate,
    required TResult Function() unableToDelete,
  }) {
    return unableToDelete();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? notFound,
    TResult? Function()? unableToUpdate,
    TResult? Function()? unableToDelete,
  }) {
    return unableToDelete?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? notFound,
    TResult Function()? unableToUpdate,
    TResult Function()? unableToDelete,
    required TResult orElse(),
  }) {
    if (unableToDelete != null) {
      return unableToDelete();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MemberUnexpected value) unexpected,
    required TResult Function(_MemberNotFound value) notFound,
    required TResult Function(_MemberUnableToUpdate value) unableToUpdate,
    required TResult Function(_MemberUnableToDelete value) unableToDelete,
  }) {
    return unableToDelete(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_MemberUnexpected value)? unexpected,
    TResult? Function(_MemberNotFound value)? notFound,
    TResult? Function(_MemberUnableToUpdate value)? unableToUpdate,
    TResult? Function(_MemberUnableToDelete value)? unableToDelete,
  }) {
    return unableToDelete?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MemberUnexpected value)? unexpected,
    TResult Function(_MemberNotFound value)? notFound,
    TResult Function(_MemberUnableToUpdate value)? unableToUpdate,
    TResult Function(_MemberUnableToDelete value)? unableToDelete,
    required TResult orElse(),
  }) {
    if (unableToDelete != null) {
      return unableToDelete(this);
    }
    return orElse();
  }
}

abstract class _MemberUnableToDelete implements MemberFailure {
  const factory _MemberUnableToDelete() = _$_MemberUnableToDelete;
}

/// @nodoc
mixin _$SplitFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() serverError,
    required TResult Function() notFound,
    required TResult Function() insufficientParticipants,
    required TResult Function() debtSumNotEqualAmount,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? serverError,
    TResult? Function()? notFound,
    TResult? Function()? insufficientParticipants,
    TResult? Function()? debtSumNotEqualAmount,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? serverError,
    TResult Function()? notFound,
    TResult Function()? insufficientParticipants,
    TResult Function()? debtSumNotEqualAmount,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SplitUnexpected value) unexpected,
    required TResult Function(_SplitServerError value) serverError,
    required TResult Function(_SplitNotFound value) notFound,
    required TResult Function(_SplitInsufficientParticipants value)
        insufficientParticipants,
    required TResult Function(_SplitDebtSumNotEqualAmount value)
        debtSumNotEqualAmount,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SplitUnexpected value)? unexpected,
    TResult? Function(_SplitServerError value)? serverError,
    TResult? Function(_SplitNotFound value)? notFound,
    TResult? Function(_SplitInsufficientParticipants value)?
        insufficientParticipants,
    TResult? Function(_SplitDebtSumNotEqualAmount value)? debtSumNotEqualAmount,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SplitUnexpected value)? unexpected,
    TResult Function(_SplitServerError value)? serverError,
    TResult Function(_SplitNotFound value)? notFound,
    TResult Function(_SplitInsufficientParticipants value)?
        insufficientParticipants,
    TResult Function(_SplitDebtSumNotEqualAmount value)? debtSumNotEqualAmount,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SplitFailureCopyWith<$Res> {
  factory $SplitFailureCopyWith(
          SplitFailure value, $Res Function(SplitFailure) then) =
      _$SplitFailureCopyWithImpl<$Res, SplitFailure>;
}

/// @nodoc
class _$SplitFailureCopyWithImpl<$Res, $Val extends SplitFailure>
    implements $SplitFailureCopyWith<$Res> {
  _$SplitFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_SplitUnexpectedCopyWith<$Res> {
  factory _$$_SplitUnexpectedCopyWith(
          _$_SplitUnexpected value, $Res Function(_$_SplitUnexpected) then) =
      __$$_SplitUnexpectedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_SplitUnexpectedCopyWithImpl<$Res>
    extends _$SplitFailureCopyWithImpl<$Res, _$_SplitUnexpected>
    implements _$$_SplitUnexpectedCopyWith<$Res> {
  __$$_SplitUnexpectedCopyWithImpl(
      _$_SplitUnexpected _value, $Res Function(_$_SplitUnexpected) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_SplitUnexpected implements _SplitUnexpected {
  const _$_SplitUnexpected();

  @override
  String toString() {
    return 'SplitFailure.unexpected()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_SplitUnexpected);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() serverError,
    required TResult Function() notFound,
    required TResult Function() insufficientParticipants,
    required TResult Function() debtSumNotEqualAmount,
  }) {
    return unexpected();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? serverError,
    TResult? Function()? notFound,
    TResult? Function()? insufficientParticipants,
    TResult? Function()? debtSumNotEqualAmount,
  }) {
    return unexpected?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? serverError,
    TResult Function()? notFound,
    TResult Function()? insufficientParticipants,
    TResult Function()? debtSumNotEqualAmount,
    required TResult orElse(),
  }) {
    if (unexpected != null) {
      return unexpected();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SplitUnexpected value) unexpected,
    required TResult Function(_SplitServerError value) serverError,
    required TResult Function(_SplitNotFound value) notFound,
    required TResult Function(_SplitInsufficientParticipants value)
        insufficientParticipants,
    required TResult Function(_SplitDebtSumNotEqualAmount value)
        debtSumNotEqualAmount,
  }) {
    return unexpected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SplitUnexpected value)? unexpected,
    TResult? Function(_SplitServerError value)? serverError,
    TResult? Function(_SplitNotFound value)? notFound,
    TResult? Function(_SplitInsufficientParticipants value)?
        insufficientParticipants,
    TResult? Function(_SplitDebtSumNotEqualAmount value)? debtSumNotEqualAmount,
  }) {
    return unexpected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SplitUnexpected value)? unexpected,
    TResult Function(_SplitServerError value)? serverError,
    TResult Function(_SplitNotFound value)? notFound,
    TResult Function(_SplitInsufficientParticipants value)?
        insufficientParticipants,
    TResult Function(_SplitDebtSumNotEqualAmount value)? debtSumNotEqualAmount,
    required TResult orElse(),
  }) {
    if (unexpected != null) {
      return unexpected(this);
    }
    return orElse();
  }
}

abstract class _SplitUnexpected implements SplitFailure {
  const factory _SplitUnexpected() = _$_SplitUnexpected;
}

/// @nodoc
abstract class _$$_SplitServerErrorCopyWith<$Res> {
  factory _$$_SplitServerErrorCopyWith(
          _$_SplitServerError value, $Res Function(_$_SplitServerError) then) =
      __$$_SplitServerErrorCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_SplitServerErrorCopyWithImpl<$Res>
    extends _$SplitFailureCopyWithImpl<$Res, _$_SplitServerError>
    implements _$$_SplitServerErrorCopyWith<$Res> {
  __$$_SplitServerErrorCopyWithImpl(
      _$_SplitServerError _value, $Res Function(_$_SplitServerError) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_SplitServerError implements _SplitServerError {
  const _$_SplitServerError();

  @override
  String toString() {
    return 'SplitFailure.serverError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_SplitServerError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() serverError,
    required TResult Function() notFound,
    required TResult Function() insufficientParticipants,
    required TResult Function() debtSumNotEqualAmount,
  }) {
    return serverError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? serverError,
    TResult? Function()? notFound,
    TResult? Function()? insufficientParticipants,
    TResult? Function()? debtSumNotEqualAmount,
  }) {
    return serverError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? serverError,
    TResult Function()? notFound,
    TResult Function()? insufficientParticipants,
    TResult Function()? debtSumNotEqualAmount,
    required TResult orElse(),
  }) {
    if (serverError != null) {
      return serverError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SplitUnexpected value) unexpected,
    required TResult Function(_SplitServerError value) serverError,
    required TResult Function(_SplitNotFound value) notFound,
    required TResult Function(_SplitInsufficientParticipants value)
        insufficientParticipants,
    required TResult Function(_SplitDebtSumNotEqualAmount value)
        debtSumNotEqualAmount,
  }) {
    return serverError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SplitUnexpected value)? unexpected,
    TResult? Function(_SplitServerError value)? serverError,
    TResult? Function(_SplitNotFound value)? notFound,
    TResult? Function(_SplitInsufficientParticipants value)?
        insufficientParticipants,
    TResult? Function(_SplitDebtSumNotEqualAmount value)? debtSumNotEqualAmount,
  }) {
    return serverError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SplitUnexpected value)? unexpected,
    TResult Function(_SplitServerError value)? serverError,
    TResult Function(_SplitNotFound value)? notFound,
    TResult Function(_SplitInsufficientParticipants value)?
        insufficientParticipants,
    TResult Function(_SplitDebtSumNotEqualAmount value)? debtSumNotEqualAmount,
    required TResult orElse(),
  }) {
    if (serverError != null) {
      return serverError(this);
    }
    return orElse();
  }
}

abstract class _SplitServerError implements SplitFailure {
  const factory _SplitServerError() = _$_SplitServerError;
}

/// @nodoc
abstract class _$$_SplitNotFoundCopyWith<$Res> {
  factory _$$_SplitNotFoundCopyWith(
          _$_SplitNotFound value, $Res Function(_$_SplitNotFound) then) =
      __$$_SplitNotFoundCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_SplitNotFoundCopyWithImpl<$Res>
    extends _$SplitFailureCopyWithImpl<$Res, _$_SplitNotFound>
    implements _$$_SplitNotFoundCopyWith<$Res> {
  __$$_SplitNotFoundCopyWithImpl(
      _$_SplitNotFound _value, $Res Function(_$_SplitNotFound) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_SplitNotFound implements _SplitNotFound {
  const _$_SplitNotFound();

  @override
  String toString() {
    return 'SplitFailure.notFound()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_SplitNotFound);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() serverError,
    required TResult Function() notFound,
    required TResult Function() insufficientParticipants,
    required TResult Function() debtSumNotEqualAmount,
  }) {
    return notFound();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? serverError,
    TResult? Function()? notFound,
    TResult? Function()? insufficientParticipants,
    TResult? Function()? debtSumNotEqualAmount,
  }) {
    return notFound?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? serverError,
    TResult Function()? notFound,
    TResult Function()? insufficientParticipants,
    TResult Function()? debtSumNotEqualAmount,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SplitUnexpected value) unexpected,
    required TResult Function(_SplitServerError value) serverError,
    required TResult Function(_SplitNotFound value) notFound,
    required TResult Function(_SplitInsufficientParticipants value)
        insufficientParticipants,
    required TResult Function(_SplitDebtSumNotEqualAmount value)
        debtSumNotEqualAmount,
  }) {
    return notFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SplitUnexpected value)? unexpected,
    TResult? Function(_SplitServerError value)? serverError,
    TResult? Function(_SplitNotFound value)? notFound,
    TResult? Function(_SplitInsufficientParticipants value)?
        insufficientParticipants,
    TResult? Function(_SplitDebtSumNotEqualAmount value)? debtSumNotEqualAmount,
  }) {
    return notFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SplitUnexpected value)? unexpected,
    TResult Function(_SplitServerError value)? serverError,
    TResult Function(_SplitNotFound value)? notFound,
    TResult Function(_SplitInsufficientParticipants value)?
        insufficientParticipants,
    TResult Function(_SplitDebtSumNotEqualAmount value)? debtSumNotEqualAmount,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound(this);
    }
    return orElse();
  }
}

abstract class _SplitNotFound implements SplitFailure {
  const factory _SplitNotFound() = _$_SplitNotFound;
}

/// @nodoc
abstract class _$$_SplitInsufficientParticipantsCopyWith<$Res> {
  factory _$$_SplitInsufficientParticipantsCopyWith(
          _$_SplitInsufficientParticipants value,
          $Res Function(_$_SplitInsufficientParticipants) then) =
      __$$_SplitInsufficientParticipantsCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_SplitInsufficientParticipantsCopyWithImpl<$Res>
    extends _$SplitFailureCopyWithImpl<$Res, _$_SplitInsufficientParticipants>
    implements _$$_SplitInsufficientParticipantsCopyWith<$Res> {
  __$$_SplitInsufficientParticipantsCopyWithImpl(
      _$_SplitInsufficientParticipants _value,
      $Res Function(_$_SplitInsufficientParticipants) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_SplitInsufficientParticipants
    implements _SplitInsufficientParticipants {
  const _$_SplitInsufficientParticipants();

  @override
  String toString() {
    return 'SplitFailure.insufficientParticipants()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SplitInsufficientParticipants);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() serverError,
    required TResult Function() notFound,
    required TResult Function() insufficientParticipants,
    required TResult Function() debtSumNotEqualAmount,
  }) {
    return insufficientParticipants();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? serverError,
    TResult? Function()? notFound,
    TResult? Function()? insufficientParticipants,
    TResult? Function()? debtSumNotEqualAmount,
  }) {
    return insufficientParticipants?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? serverError,
    TResult Function()? notFound,
    TResult Function()? insufficientParticipants,
    TResult Function()? debtSumNotEqualAmount,
    required TResult orElse(),
  }) {
    if (insufficientParticipants != null) {
      return insufficientParticipants();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SplitUnexpected value) unexpected,
    required TResult Function(_SplitServerError value) serverError,
    required TResult Function(_SplitNotFound value) notFound,
    required TResult Function(_SplitInsufficientParticipants value)
        insufficientParticipants,
    required TResult Function(_SplitDebtSumNotEqualAmount value)
        debtSumNotEqualAmount,
  }) {
    return insufficientParticipants(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SplitUnexpected value)? unexpected,
    TResult? Function(_SplitServerError value)? serverError,
    TResult? Function(_SplitNotFound value)? notFound,
    TResult? Function(_SplitInsufficientParticipants value)?
        insufficientParticipants,
    TResult? Function(_SplitDebtSumNotEqualAmount value)? debtSumNotEqualAmount,
  }) {
    return insufficientParticipants?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SplitUnexpected value)? unexpected,
    TResult Function(_SplitServerError value)? serverError,
    TResult Function(_SplitNotFound value)? notFound,
    TResult Function(_SplitInsufficientParticipants value)?
        insufficientParticipants,
    TResult Function(_SplitDebtSumNotEqualAmount value)? debtSumNotEqualAmount,
    required TResult orElse(),
  }) {
    if (insufficientParticipants != null) {
      return insufficientParticipants(this);
    }
    return orElse();
  }
}

abstract class _SplitInsufficientParticipants implements SplitFailure {
  const factory _SplitInsufficientParticipants() =
      _$_SplitInsufficientParticipants;
}

/// @nodoc
abstract class _$$_SplitDebtSumNotEqualAmountCopyWith<$Res> {
  factory _$$_SplitDebtSumNotEqualAmountCopyWith(
          _$_SplitDebtSumNotEqualAmount value,
          $Res Function(_$_SplitDebtSumNotEqualAmount) then) =
      __$$_SplitDebtSumNotEqualAmountCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_SplitDebtSumNotEqualAmountCopyWithImpl<$Res>
    extends _$SplitFailureCopyWithImpl<$Res, _$_SplitDebtSumNotEqualAmount>
    implements _$$_SplitDebtSumNotEqualAmountCopyWith<$Res> {
  __$$_SplitDebtSumNotEqualAmountCopyWithImpl(
      _$_SplitDebtSumNotEqualAmount _value,
      $Res Function(_$_SplitDebtSumNotEqualAmount) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_SplitDebtSumNotEqualAmount implements _SplitDebtSumNotEqualAmount {
  const _$_SplitDebtSumNotEqualAmount();

  @override
  String toString() {
    return 'SplitFailure.debtSumNotEqualAmount()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SplitDebtSumNotEqualAmount);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() serverError,
    required TResult Function() notFound,
    required TResult Function() insufficientParticipants,
    required TResult Function() debtSumNotEqualAmount,
  }) {
    return debtSumNotEqualAmount();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? serverError,
    TResult? Function()? notFound,
    TResult? Function()? insufficientParticipants,
    TResult? Function()? debtSumNotEqualAmount,
  }) {
    return debtSumNotEqualAmount?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? serverError,
    TResult Function()? notFound,
    TResult Function()? insufficientParticipants,
    TResult Function()? debtSumNotEqualAmount,
    required TResult orElse(),
  }) {
    if (debtSumNotEqualAmount != null) {
      return debtSumNotEqualAmount();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SplitUnexpected value) unexpected,
    required TResult Function(_SplitServerError value) serverError,
    required TResult Function(_SplitNotFound value) notFound,
    required TResult Function(_SplitInsufficientParticipants value)
        insufficientParticipants,
    required TResult Function(_SplitDebtSumNotEqualAmount value)
        debtSumNotEqualAmount,
  }) {
    return debtSumNotEqualAmount(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SplitUnexpected value)? unexpected,
    TResult? Function(_SplitServerError value)? serverError,
    TResult? Function(_SplitNotFound value)? notFound,
    TResult? Function(_SplitInsufficientParticipants value)?
        insufficientParticipants,
    TResult? Function(_SplitDebtSumNotEqualAmount value)? debtSumNotEqualAmount,
  }) {
    return debtSumNotEqualAmount?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SplitUnexpected value)? unexpected,
    TResult Function(_SplitServerError value)? serverError,
    TResult Function(_SplitNotFound value)? notFound,
    TResult Function(_SplitInsufficientParticipants value)?
        insufficientParticipants,
    TResult Function(_SplitDebtSumNotEqualAmount value)? debtSumNotEqualAmount,
    required TResult orElse(),
  }) {
    if (debtSumNotEqualAmount != null) {
      return debtSumNotEqualAmount(this);
    }
    return orElse();
  }
}

abstract class _SplitDebtSumNotEqualAmount implements SplitFailure {
  const factory _SplitDebtSumNotEqualAmount() = _$_SplitDebtSumNotEqualAmount;
}
